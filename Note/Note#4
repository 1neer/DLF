먼저 우리가 지금까지 Dezero에서 구현한 함수들은 입력과 출력이 모두 스칼라값이라고 가정하였다. 하지만, 이것을 텐서를 이용해 계산할 때에도
역전파는 문제없이 동작한다. 이는 원소별 연산을 수행하느냐 안하느냐의 차이인데, 텐서의 형상을 변환시켜주는 reshape함수와 transpose함수를
구현할때에는 어떻게 해야하는지 알아보았다.

reshape 함수는 먼저 형상만 변화하므로 계산은 아무것도 하지 않는다. 때문에 역전파는 출력쪽에서 전해지는 기울기를 그대로 입력쪽으로 흘려보낸다.
그리고, 기울기의 형상이 입력의 형상과 같아지도록 변환해야한다. 때문에 순전파시에 입력x으 형상을 기억해두고, 역전파에서 형상을 변환시킨다.
이렇게 구현한 reshape함수는 형상을 변환시키고, 역전파를 진행할시에 y의 기울기가 자동으로 채워진다.

다음으로는 행렬을 전치시켜주는 transpose함수를 구현하였다. 이또한 reshape함수와 마찬가지로 텐서의 원소 자체는 그대로이지만, 형상만 바뀐다.
때문에 역전파에서는 출력쪽에서 전해지는 기울기의 형상만 변경한다.
이를 구현하기위해 순전파시에 np.transpose함수를 사용하여서 전치시킨뒤에 역전파는 출력쪽에서 전해지는 기울기를 transpose 함수를 사용해서 반환한다.
역전파에서는 순전파외는 반대의 변환이 이루어진다.

그런다음 Dezero에 합계를 구하는 함수인 sum함수를 추가하였다.
먼저 덧셈의 미분은 y = 𝒙𝟎 + 𝒙1 일때 기울기가 각각 1, 1이므로 역전파는 출력쪽에서 전해지는 기울기를 그대로 입력쪽으로 흘려보낸다.
먼저 벡터에 sum함수를 적용하면 스칼라를 출력한다. 그리고 역전파는 출력쪽에서 전해준 값인 1을 [1, 1]이라는 벡터로 확장해서 전파한다.
또한 원소가 2개 이상이라면, 기울기 벡터의 원소수만큼 복사하고, 기울기를 입력 변수의 형상과 같아지도록 복사한다.
그 후 sum함수를 구현할때는 지정한 형상에 맞게 원소를 복사하기 위해 broadcast_to함수를 사용하고, 입력 변수와 형상이 같아지도록 기울기
gy의 원소를 복사한다. 또한 행렬을 입력해서 벡터가 아닌 경우의 동작을 확인한다.
또한 합계를 구할때 죽을 지정할 수 있는데 이를 axis 지정 인수라 한다. axis = 0이면 열을 더하고, axis = 1이면 행을 더한다.
다음으로는 keepdims인수가 있는데 이는 입력과 출력의 차원 수를 똑같게 유지할지 정하는 플래그이다. 
keepdims=True 로 지정하면 축의 수가 유지되고, keepdims=False로 지정하면 y의 형상은 스칼라가 된다.
다음으로는 브로드 캐스트 함수를 구현하였다. 브로드캐스트 함수는 서로 다른 형상을 가진 배열들간에 산술 연산을 수행하기 위해 
배열의 형상을 조정하는 함수이다. 브로드캐스트를 사용하여 작은 배열을 큰 배열에 맞추어 연산을 수행할 수 있다.
이 브로드캐스트 함수의 역전파는 입력 x의 형상과 같아지도록 기울기의 합을 구한다. 이는 sum_to( x, shape) 함수가 있으면 간단하게 해결된다.

다음으로는 행렬의 곱이다. 만약 두 벡터으 행이나 열이 하나라면 내적을 진행하고, 그렇지 않다면 행렬의 곱을 진행한다.
이 행렬과 벡터를 사용한 계산을 할때 주의할점은 행렬 a와 b의 대응하는 차원의 원소 수가 일치해야 한다.

다음으로는 선형회귀를 구현했다. 선형회귀는 평균제곱 오차를 손실함수로 삼고, 이 손실함수 값을 최소로 하도록 학습을 진행한다.
이를위해 데이터의 예측치를 구하는 predict함수를 구현하고 평균제곱오차를 구하는 함수를 구현한 뒤, 경사하강법으로 배개변수를 갱신시킨다.

다음으로는 구현한 선형회귀를 신경망으로 확장시킨다. 이를위해 linear함수를 구현하고, 활성화 함수라는 것을 사용하는데, 이 활성화 함수는
선형 변환은 입력 데이터를 선형으로 변환해 주고 신경망은 선형 변환의 출력에 비선형 변환을 수행해준다. 이 비선형 변환이 활성화 함수이다.
이 부분에서는 그중에서도 시그모이드 함수를 사용하였다.

다음으로는 매개변수를 모아두는 계층을 만들어서 관리를 더욱 편하게 만들어 주고, 계층을 모아두는 계층을 만들어 Layer클래스를 사용할 시 사용자가
직접 다루지 않아도 되게끔 구현하였다. 마지막으로 모델을 표현하기 위해 Model 클래스를 만들어 모든 매개변수를 Model을 통해 접근할 수 있도록
만들어 놓았다.
